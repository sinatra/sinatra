= Sinatra

Sinatra é uma DSL para criar rapidamente aplicações web em Ruby com o mínimo de esforço:

  # minhaapp.rb
  require 'rubygems'
  require 'sinatra'
  get '/' do
    'Olá Mundo!'
  end

Instale a gem e execute como:

  sudo gem install sinatra
  ruby minhaapp.rb

Acesse em: http://localhost:4567

== Rotas

No Sinatra, uma rota é um metodo HTTP associado a uma URL correspondente padrão.
Cada rota é associada a um bloco:

  get '/' do
    .. mostrando alguma coisa ..
  end

  post '/' do
    .. criando alguma coisa ..
  end

  put '/' do
    .. atualizando alguma coisa ..
  end

  delete '/' do
    .. apagando alguma coisa ..
  end

Rotas são encontradas na ordem em que são definidas. A primeira rota que
é encontrada o pedido é invocado.

Padrões de rota podem incluir parâmetros nomeados, acessáveis via a
hash <tt>params</tt>:

  get '/ola/:nome' do
    # corresponde a "GET /ola/foo" e "GET /ola/bar"
    # params[:nome] é 'foo' ou 'bar'
    "Olá #{params[:nome]}!"
  end

Você também pode acessar parâmetros nomeados via bloco de parâmetros:

  get '/ola/:nome' do |n|
    "Olá #{n}!"
  end

Padrões de rota também podem incluir parâmetros splat (ou curingas), acessáveis
via o array <tt>params[:splat]</tt>.

  get '/diga/*/para/*' do
    # corresponde a /diga/ola/para/mundo
    params[:splat] # => ["ola", "mundo"]
  end

  get '/download/*.*' do
    # corresponde a /download/pasta/do/arquivo.xml
    params[:splat] # => ["pasta/do/arquivo", "xml"]
  end

Rotas se correspondem com expressões regulares:

  get %r{/ola/([\w]+)} do
    "Olá, #{params[:captures].first}!"
  end

Ou com um bloco de parâmetro:

  get %r{/ola/([\w]+)} do |c|
    "Hello, #{c}!"
  end

Rotas podem incluir uma variedade de condições correspondes, tal como o agente usuário:

  get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
    "Você está utilizando a versão #{params[:agent][0]} do Songbird."
  end

  get '/foo' do
    # Corresponde a um navegador não Songbird
  end

== Arquivos estáticos

Arquivos estáticos são disponibilizados a partir do diretório <tt>./public</tt>. Você pode especificar
um local diferente pela opção <tt>:public</tt>

  set :public, File.dirname(__FILE__) + '/estatico'

Note que o nome do diretório público não é incluido na URL. Um arquivo
<tt>./public/css/style.css</tt> é disponibilizado como
<tt>http://example.com/css/style.css</tt>.

== Views / Templates

Templates presumem-se estar localizados sob o diretório <tt>./views</tt>.
Para utilizar um diretório view diferente:

  set :views, File.dirname(__FILE__) + '/modelo'

Uma coisa importante a ser lembrada é que você sempre tem as referências dos
templates como simbolos, mesmo se eles estiverem em um sub-diretório (nesse
caso utilize <tt>:'subdir/template'</tt>). Métodos de renderização irão processar
qualquer string passada diretamente para elas.

=== Haml Templates

A gem/biblioteca haml é necessária para renderizar templates HAML:

  ## Você precisa do 'require haml' em sua aplicação.
  require 'haml'

  get '/' do
    haml :index
  end

Renderiza <tt>./views/index.haml</tt>.

{Opções Haml}[http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options]
podem ser setadas globalmente através das configurações do sinatra,
veja {Opções e Configurações}[http://www.sinatrarb.com/configuration.html],
e substitua em uma requisição individual.

  set :haml, {:format => :html5 } # o formato padrão do Haml é :xhtml

  get '/' do
    haml :index, :haml_options => {:format => :html4 } # substituido
  end


=== Erb Templates

  ## Você precisa do 'require erb' em sua aplicação
  require 'erb'

  get '/' do
    erb :index
  end

Renderiza <tt>./views/index.erb</tt>

=== Erubis

A gem/biblioteca erubis é necessária para renderizar templates erubis:

  ## Você precisa do 'require erubis' em sua aplicação.
  require 'erubis'

  get '/' do
    erubis :index
  end

Renderiza <tt>./views/index.erubis</tt>

=== Builder Templates

A gem/biblioteca builder é necessária para renderizar templates builder:

  ## Você precisa do 'require builder' em sua aplicação.
  require 'builder'

  get '/' do
    content_type 'application/xml', :charset => 'utf-8'
    builder :index
  end

Renderiza <tt>./views/index.builder</tt>.

=== Sass Templates

A gem/biblioteca sass é necessária para renderizar templates sass:

  ## Você precisa do 'require haml' ou 'require sass' em sua aplicação.
  require 'sass'

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    sass :stylesheet
  end

Renderiza <tt>./views/stylesheet.sass</tt>.

{Opções Sass}[http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options]
podem ser setadas globalmente através das configurações do sinatra,
veja {Opções e Configurações}[http://www.sinatrarb.com/configuration.html],
e substitua em uma requisição individual.

  set :sass, {:style => :compact } # o estilo padrão do Sass é :nested

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    sass :stylesheet, :style => :expanded # substituido
  end

=== Less Templates

A gem/biblioteca less é necessária para renderizar templates Less:

  ## Você precisa do 'require less' em sua aplicação.
  require 'less'

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    less :stylesheet
  end

Renderiza <tt>./views/stylesheet.less</tt>.

=== Inline Templates

  get '/' do
    haml '%div.title Olá Mundo'
  end

Renderiza a string, em uma linha, no template.

=== Acessando Variáveis nos Templates

Templates são avaliados dentro do mesmo contexto como manipuladores de rota. Variáveis
de instância setadas em rotas manipuladas são diretamente acessadas por templates:

  get '/:id' do
    @foo = Foo.find(params[:id])
    haml '%h1= @foo.nome'
  end

Ou, especifique um hash explícito para variáveis locais:

  get '/:id' do
    foo = Foo.find(params[:id])
    haml '%h1= foo.nome', :locals => { :foo => foo }
  end

Isso é tipicamente utilizando quando renderizamos templates como partials dentro
de outros templates.

=== Templates Inline

Templates podem ser definidos no final do arquivo fonte(.rb):

  require 'rubygems'
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Olá Mundo!!!!!

NOTA: Templates inline definidos no arquivo fonte são automaticamente carregados
pelo sinatra. Digite `enable :inline_templates` se você tem templates
inline no outro arquivo fonte.

=== Templates nomeados

Templates também podem ser definidos utilizando o  método top-level <tt>template</tt>:

  template :layout do
    "%html\n  =yield\n"
  end

  template :index do
    '%div.title Olá Mundo!'
  end

  get '/' do
    haml :index
  end

Se existir um template com nome "layout", ele será utilizado toda vez que um
template for renderizado. Você pode desabilitar layouts passando <tt>:layout => false</tt>.

  get '/' do
    haml :index, :layout => !request.xhr?
  end

== Helpers

Use o método top-level <tt>helpers</tt> para definir métodos auxiliares para utilizar em
manipuladores de rotas e modelos:

  helpers do
    def bar(nome)
      "#{nome}bar"
    end
  end

  get '/:nome' do
    bar(params[:nome])
  end

== Filtros

Filtros Before são avaliados antes de cada requisição dentro do contexto da requisição
e pode modificar a requisição e a reposta. Variáveis de instância setadas nos
filtros são acessadas através de rotas e templates:

  before do
    @nota = 'Oi!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @nota #=> 'Oi!'
    params[:splat] #=> 'bar/baz'
  end

Filtros After são avaliados após cada requisição dentro do contexto da
requisição e também podem modificar o pedido e a resposta. Variáveis de instância
definidas nos filtros before e rotas são acessadas através dos filtros after:

  after do
    puts response.status
  end

Filtros opcionalmente tem um padrão, fazendo com que sejam avaliados somente se o caminho
do pedido coincidir com esse padrão:

  before '/protected/*' do
    authenticate!
  end

  after '/create/:slug' do |slug|
    session[:last_slug] = slug
  end

== Halting

Para parar imediatamente uma requisição com um filtro ou rota utilize:

  halt

Você também pode especificar o status quando parar...

  halt 410

Ou com corpo de texto...

  halt 'isso será o corpo do texto'

Ou também...

  halt 401, 'vamos embora!'

Com cabeçalhos...

  halt 402, {'Content-Type' => 'text/plain'}, 'revanche'

== Passing

Uma rota pode processar aposta para a próxima rota correspondente usando <tt>pass</tt>:

  get '/adivinhar/:quem' do
    pass unless params[:quem] == 'Frank'
    'Você me pegou!'
  end

  get '/adivinhar/*' do
    'Você falhou!'
  end

O bloqueio da rota é imediatamente encerrado e o controle continua com a próxima
rota de parâmetro. Se o parâmetro da rota não for encontrado, um 404 é retornado.

== Configuração

Rodando uma vez, na inicialização, em qualquer ambiente:

  configure do
    ...
  end

Rodando somente quando o ambiente (RACK_ENV environment variável) é setado para
<tt>:production</tt>:

  configure :production do
    ...
  end

Rodando quando o ambiente é setado para <tt>:production</tt> ou
<tt>:test</tt>:

  configure :production, :test do
    ...
  end

== Tratamento de Erros

Tratamento de erros rodam dentro do mesmo contexto como rotas e filtros before, which
means you get all the goodies it has to offer, like <tt>haml</tt>, <tt>erb</tt>,
<tt>halt</tt>, etc.

=== Não Encontrado

Quando um <tt>Sinatra::NotFound</tt> exception é levantada, ou o response's status
code is 404, the <tt>not_found</tt> handler is invoked:

  not_found do
    'This is nowhere to be found'
  end

=== Error

The +error+ handler is invoked any time an exception is raised from a route
block or a filter. The exception object can be obtained from the
<tt>sinatra.error</tt> Rack variable:

  error do
    'Sorry there was a nasty error - ' + env['sinatra.error'].name
  end

Custom errors:

  error MyCustomError do
    'So what happened was...' + request.env['sinatra.error'].message
  end

Then, if this happens:

  get '/' do
    raise MyCustomError, 'something bad'
  end

You get this:

  So what happened was... something bad

Alternatively, you can install error handler for a status code:

  error 403 do
    'Access forbidden'
  end

  get '/secret' do
    403
  end

Or a range:

  error 400..510 do
    'Boom'
  end

Sinatra installs special <tt>not_found</tt> and <tt>error</tt> handlers when
running under the development environment.

== Mime types

When using <tt>send_file</tt> or static files you may have mime types Sinatra
doesn't understand. Use +mime_type+ to register them by file extension:

  mime_type :foo, 'text/foo'

You can also use it with the +content_type+ helper:

  content_type :foo

== Rack Middleware

Sinatra rides on Rack[http://rack.rubyforge.org/], a minimal standard
interface for Ruby web frameworks. One of Rack's most interesting capabilities
for application developers is support for "middleware" -- components that sit
between the server and your application monitoring and/or manipulating the
HTTP request/response to provide various types of common functionality.

Sinatra makes building Rack middleware pipelines a cinch via a top-level
+use+ method:

  require 'sinatra'
  require 'my_custom_middleware'

  use Rack::Lint
  use MyCustomMiddleware

  get '/ola' do
    'Olá mundo'
  end

A semântica of +use+ are identical to those defined for the
Rack::Builder[http://rack.rubyforge.org/doc/classes/Rack/Builder.html] DSL
(most frequently used from rackup files). For example, the +use+ method
accepts multiple/variable args as well as blocks:

  use Rack::Auth::Basic do |username, password|
    username == 'admin' && password == 'secret'
  end

Rack is distributed with a variety of standard middleware for logging,
debugging, URL routing, authentication, and session handling. Sinatra uses
many of of these components automatically based on configuration so you
typically don't have to +use+ them explicitly.

== Testando

Testes no Sinatra podem ser escritos utilizando qualquer biblioteca ou framework
de teste baseados no Rack. {Rack::Test}[http://gitrdoc.com/brynary/rack-test] é
recomendado:

  require 'my_sinatra_app'
  require 'rack/test'

  class MyAppTest < Test::Unit::TestCase
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    def test_my_default
      get '/'
      assert_equal 'Ola Mundo!', last_response.body
    end

    def test_with_params
      get '/meet', :name => 'Frank'
      assert_equal 'Hello Frank!', last_response.body
    end

    def test_with_rack_env
      get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
      assert_equal "You're using Songbird!", last_response.body
    end
  end

NOTE: The built-in Sinatra::Test module and Sinatra::TestHarness class
are deprecated as of the 0.9.2 release.

== Sinatra::Base - Middleware, Libraries, and Modular Apps

Defining your app at the top-level works well for micro-apps but has
considerable drawbacks when building reuseable components such as Rack
middleware, Rails metal, simple libraries with a server component, or
even Sinatra extensions. The top-level DSL pollutes the Object namespace
and assumes a micro-app style configuration (e.g., a single application
file, ./public and ./views directories, logging, exception detail page,
etc.). That's where Sinatra::Base comes into play:

  require 'sinatra/base'

  class MinhaApp < Sinatra::Base
    set :sessions, true
    set :foo, 'bar'

    get '/' do
      'Ola mundo!'
    end
  end

A classe MinhaApp é an independent Rack component that can act as
Rack middleware, a Rack application, or Rails metal. You can +use+ or
+run+ this class from a rackup +config.ru+ file; or, control a server
component shipped as a library:

   MyApp.run! :host => 'localhost', :port => 9090

Os métodos disponíveis para Sinatra::Base subclasses are exactly as those
available via the top-level DSL. Most top-level apps can be converted to
Sinatra::Base components with two modifications:

* Your file should require +sinatra/base+  instead of +sinatra+;
  otherwise, all of Sinatra's DSL methods are imported into the main
  namespace.
* Put your app's routes, error handlers, filters, and options in a subclass
  of Sinatra::Base.

+Sinatra::Base+ is a blank slate. Most options are disabled by default,
including the built-in server. See {Options and Configuration}[http://sinatra.github.com/configuration.html]
for details on available options and their behavior.

SIDEBAR: Sinatra's top-level DSL is implemented using a simple delegation
system. The +Sinatra::Application+ class -- a special subclass of
Sinatra::Base -- receives all :get, :put, :post, :delete, :before,
:error, :not_found, :configure, and :set messages sent to the
top-level. Have a look at the code for yourself: here's the
{Sinatra::Delegator mixin}[http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128]
being {included into the main namespace}[http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28]

== Linha de Comando

Sinatra applications can be run directly:

  ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]

Options are:

  -h # help
  -p # set the port (default is 4567)
  -o # set the host (default is 0.0.0.0)
  -e # set the environment (default is development)
  -s # specify rack server/handler (default is thin)
  -x # turn on the mutex lock (default is off)

== The Bleeding Edge

If you would like to use Sinatra's latest bleeding code, create a local
clone and run your app with the <tt>sinatra/lib</tt> directory on the
<tt>LOAD_PATH</tt>:

  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb

Alternatively, you can add the <tt>sinatra/lib</tt> directory to the
<tt>LOAD_PATH</tt> in your application:

  $LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
  require 'rubygems'
  require 'sinatra'

  get '/about' do
    "I'm running version " + Sinatra::VERSION
  end

Para atualizar o código do Sinatra no futuro:

  cd meuprojeto/sinatra
  git pull

== Mais

* {Project Website}[http://www.sinatrarb.com/] - Documentação adicional,
  news, and links to other resources.
* {Contributing}[http://www.sinatrarb.com/contributing] - Find a bug? Need
  help? Have a patch?
* {Issue tracker}[http://github.com/sinatra/sinatra/issues]
* {Twitter}[http://twitter.com/sinatra]
* {Mailing List}[http://groups.google.com/group/sinatrarb/topics]
* {IRC: #sinatra}[irc://chat.freenode.net/#sinatra] on http://freenode.net
